use tcp

everything is json

conn always closed by client in normal cases
conn always closed by server in exceptional cases

server can always return an { Error: string },
only for exceptional internal errors, not for business logic

client
	server
	. peer
	b broadcast, same msg for all
	r broadcast, rotate perspective

{ Type: "login", Version: "0.6.5", Username: "...", Password: "..." }
{ Type: "sign-up", Version: "...", Username: "...", Password: "..." }
	. { Type: "auth", Ok: false, Reason: "..." } close
	. { Type: "auth", Ok: true, User: {...} }

{ Type: "look-around" }
	. { Type: "look-around", Book: bool, Conn: int, ... }

{ Type: "book" }
	r { Type: "start", Users: [...], GirlIds: [...], TempDealer: ? }
{ Type: "ready" }
	r { Type: "t-points-changed", Points: [...] }
	. { Type: "t-activated", Actions: [ (dice) ] }
{ Type: "t-action", ActStr: "...", ActArg: "..." }
	r { Type: "t-first-dealer-choosen", InitDealer: ? }
	r { Type: "t-round-started", Round: ?, ExtraRound, ?, ... }
	b { Type: "t-cleaned" }
	b { Type: "t-diced" }
	r { Type: "t-dealt", Init: [ {...}, ... ] }
	b { Type: "t-flipped", NewIndic: {...} }
	r { Type: "t-drawn", ... }
	r { Type: "t-discarded", ... }
	r { Type: "t-riichi-called", Who: ? }
	r { Type: "t-riichi-established", Who: ? }
	r { Type: "t-barked", Who: ?, FromWhom: ?, ... }
	r { Type: "t-round-ended", ... }
	r { Type: "t-points-changed", Points: [...] }
	r { Type: "t-table-ended", ... }
	r { Type: "t-popped-up", ... }

server
	client
{ Type: update-user, User: {...} }



